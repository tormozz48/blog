<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Tree BFS (Breadth-First Search)</title>
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/prism-theme.css">
</head>
<body>
    <header>
        <nav>
            <ul style="display: flex; flex-direction: row; list-style: none; padding: 0; margin: 0;">
                <li style="margin-right: 20px;"><a href="/">Home</a></li>
                <li style="margin-right: 20px;"><a href="/cv/">CV</a></li>
                <li style="margin-right: 20px;"><a href="/blog/">Blog</a></li>
                <li><a href="/algorithms/">Algorithms</a></li>
            </ul>
        </nav>
    </header>
    
    <main>
        
<article class="algorithm-page">
    <header class="algorithm-header">
        <h1>Binary Tree BFS (Breadth-First Search)</h1>
        <p class="algorithm-description">A technique to traverse or search a binary tree by exploring all nodes at the present depth before moving to nodes at the next depth level</p>
    </header>

    <div class="algorithm-content">
        <h1>Binary Tree BFS (Breadth-First Search)</h1>
<h2>Description</h2>
<p>Breadth-First Search (BFS) is a traversal algorithm that explores a binary tree level by level, visiting all nodes at the current depth before moving to nodes at the next depth level. This approach is implemented using a queue data structure to keep track of nodes to visit.</p>
<h2>Use Cases</h2>
<ul>
<li>Level-order traversal of a binary tree</li>
<li>Finding the shortest path in an unweighted tree</li>
<li>Computing the minimum depth of a binary tree</li>
<li>Finding the closest nodes to the root</li>
<li>Checking if a binary tree is complete</li>
<li>Connecting nodes at the same level</li>
</ul>
<h2>Code Example</h2>
<pre><code class="language-typescript">/**
 * Definition for a binary tree node
 */
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    
    constructor(val: number = 0, left: TreeNode | null = null, right: TreeNode | null = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

/**
 * Level-order traversal of a binary tree
 * 
 * @param root Root of the binary tree
 * @returns Array of node values in level-order traversal
 */
function levelOrderTraversal(root: TreeNode | null): number[] {
    if (root === null) return [];
    
    const result: number[] = [];
    const queue: TreeNode[] = [root];
    
    while (queue.length &gt; 0) {
        // Get the node at the front of the queue
        const node = queue.shift()!;
        
        // Visit the node
        result.push(node.val);
        
        // Add its children to the queue
        if (node.left !== null) {
            queue.push(node.left);
        }
        if (node.right !== null) {
            queue.push(node.right);
        }
    }
    
    return result;
}

/**
 * Level-by-level traversal of a binary tree
 * 
 * @param root Root of the binary tree
 * @returns Array of arrays, where each inner array contains node values at the same level
 */
function levelByLevelTraversal(root: TreeNode | null): number[][] {
    if (root === null) return [];
    
    const result: number[][] = [];
    const queue: TreeNode[] = [root];
    
    while (queue.length &gt; 0) {
        const levelSize = queue.length;
        const currentLevel: number[] = [];
        
        // Process all nodes at the current level
        for (let i = 0; i &lt; levelSize; i++) {
            const node = queue.shift()!;
            
            // Add to current level
            currentLevel.push(node.val);
            
            // Add children to the queue for the next level
            if (node.left !== null) {
                queue.push(node.left);
            }
            if (node.right !== null) {
                queue.push(node.right);
            }
        }
        
        // Add the current level to the result
        result.push(currentLevel);
    }
    
    return result;
}

/**
 * Problem: Find the minimum depth of a binary tree
 * (The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node)
 * 
 * @param root Root of the binary tree
 * @returns Minimum depth of the binary tree
 */
function minDepth(root: TreeNode | null): number {
    if (root === null) return 0;
    
    const queue: [TreeNode, number][] = [[root, 1]]; // [node, depth]
    
    while (queue.length &gt; 0) {
        const [node, depth] = queue.shift()!;
        
        // If this is a leaf node, return its depth
        if (node.left === null &amp;&amp; node.right === null) {
            return depth;
        }
        
        // Add children to the queue with incremented depth
        if (node.left !== null) {
            queue.push([node.left, depth + 1]);
        }
        if (node.right !== null) {
            queue.push([node.right, depth + 1]);
        }
    }
    
    return 0; // Should never reach here if the tree is valid
}

// Example usage
// Create a binary tree:
//       1
//      / \
//     2   3
//    / \
//   4   5
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);

console.log(&quot;Level-order traversal:&quot;, levelOrderTraversal(root));
// Output: Level-order traversal: [1, 2, 3, 4, 5]

console.log(&quot;Level-by-level traversal:&quot;, levelByLevelTraversal(root));
// Output: Level-by-level traversal: [[1], [2, 3], [4, 5]]

console.log(&quot;Minimum depth:&quot;, minDepth(root));
// Output: Minimum depth: 2
</code></pre>
<h2>LeetCode Example Problems</h2>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">LeetCode 102. Binary Tree Level Order Traversal</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">LeetCode 107. Binary Tree Level Order Traversal II</a></li>
<li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">LeetCode 111. Minimum Depth of Binary Tree</a></li>
<li><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">LeetCode 116. Populating Next Right Pointers in Each Node</a></li>
</ul>
<h2>Complexity Analysis</h2>
<ul>
<li><strong>Time Complexity</strong>: O(n) where n is the number of nodes in the binary tree. We visit each node exactly once.</li>
<li><strong>Space Complexity</strong>: O(w) where w is the maximum width of the binary tree. In the worst case, the queue might contain all nodes at the widest level of the tree. For a complete binary tree, this could be up to n/2 nodes.</li>
</ul>
<h2>When to Use</h2>
<p>Use Binary Tree BFS when:</p>
<ul>
<li>You need to traverse a tree level by level</li>
<li>You're looking for the shortest path in an unweighted tree</li>
<li>You need to find the minimum depth of a tree</li>
<li>You want to process nodes based on their distance from the root</li>
<li>You're solving problems that involve connecting nodes at the same level</li>
</ul>

    </div>

    <div class="algorithm-navigation">
        <div class="algorithm-nav-links">
            
                
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                        
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                

                
                

                <div class="algorithm-nav-previous">
                    
                        <a href="/algorithms/05_binary_tree_dfs/" class="algorithm-nav-link">
                            <span class="algorithm-nav-direction">Previous</span>
                            <span class="algorithm-nav-title">Binary Tree DFS (Depth-First Search)</span>
                        </a>
                    
                </div>

                <div class="algorithm-nav-index">
                    <a href="/algorithms/" class="algorithm-index-link">All Algorithms</a>
                </div>

                <div class="algorithm-nav-next">
                    
                        <a href="/algorithms/07_heap/" class="algorithm-nav-link">
                            <span class="algorithm-nav-direction">Next</span>
                            <span class="algorithm-nav-title">Heap Data Structure</span>
                        </a>
                    
                </div>
            
        </div>
    </div>
</article>

    </main>
    
    <footer>
        <p>&copy; 2025 Andrii Kuznietsov. All rights reserved.</p>
    </footer>
    <script src="/assets/js/animation.js"></script>
</body>
</html>
