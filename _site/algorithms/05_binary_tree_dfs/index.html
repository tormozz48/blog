<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Tree DFS (Depth-First Search)</title>
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/prism-theme.css">
</head>
<body>
    <header>
        <nav>
            <ul style="display: flex; flex-direction: row; list-style: none; padding: 0; margin: 0;">
                <li style="margin-right: 20px;"><a href="/">Home</a></li>
                <li style="margin-right: 20px;"><a href="/cv/">CV</a></li>
                <li style="margin-right: 20px;"><a href="/blog/">Blog</a></li>
                <li><a href="/algorithms/">Algorithms</a></li>
            </ul>
        </nav>
    </header>
    
    <main>
        
<article class="algorithm-page">
    <header class="algorithm-header">
        <h1>Binary Tree DFS (Depth-First Search)</h1>
        <p class="algorithm-description">A technique to traverse or search a binary tree by exploring as far as possible along each branch before backtracking</p>
    </header>

    <div class="algorithm-content">
        <h1>Binary Tree DFS (Depth-First Search)</h1>
<h2>Description</h2>
<p>Depth-First Search (DFS) is a traversal algorithm that explores a binary tree by going as deep as possible along each branch before backtracking. There are three common ways to perform DFS on a binary tree: preorder (root, left, right), inorder (left, root, right), and postorder (left, right, root) traversal.</p>
<h2>Use Cases</h2>
<ul>
<li>Searching for a node in a binary tree</li>
<li>Computing the height or depth of a binary tree</li>
<li>Checking if a binary tree is balanced</li>
<li>Validating if a binary tree is a valid BST (Binary Search Tree)</li>
<li>Serializing and deserializing a binary tree</li>
<li>Finding paths in a binary tree that satisfy certain conditions</li>
</ul>
<h2>Code Example</h2>
<pre><code class="language-typescript">/**
 * Definition for a binary tree node
 */
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    
    constructor(val: number = 0, left: TreeNode | null = null, right: TreeNode | null = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

/**
 * Preorder traversal: Root -&gt; Left -&gt; Right
 * 
 * @param root Root of the binary tree
 * @returns Array of node values in preorder traversal
 */
function preorderTraversal(root: TreeNode | null): number[] {
    const result: number[] = [];
    
    function dfs(node: TreeNode | null): void {
        if (node === null) return;
        
        // Visit the root first
        result.push(node.val);
        
        // Then traverse left subtree
        dfs(node.left);
        
        // Finally traverse right subtree
        dfs(node.right);
    }
    
    dfs(root);
    return result;
}

/**
 * Inorder traversal: Left -&gt; Root -&gt; Right
 * 
 * @param root Root of the binary tree
 * @returns Array of node values in inorder traversal
 */
function inorderTraversal(root: TreeNode | null): number[] {
    const result: number[] = [];
    
    function dfs(node: TreeNode | null): void {
        if (node === null) return;
        
        // Traverse left subtree first
        dfs(node.left);
        
        // Then visit the root
        result.push(node.val);
        
        // Finally traverse right subtree
        dfs(node.right);
    }
    
    dfs(root);
    return result;
}

/**
 * Postorder traversal: Left -&gt; Right -&gt; Root
 * 
 * @param root Root of the binary tree
 * @returns Array of node values in postorder traversal
 */
function postorderTraversal(root: TreeNode | null): number[] {
    const result: number[] = [];
    
    function dfs(node: TreeNode | null): void {
        if (node === null) return;
        
        // Traverse left subtree first
        dfs(node.left);
        
        // Then traverse right subtree
        dfs(node.right);
        
        // Finally visit the root
        result.push(node.val);
    }
    
    dfs(root);
    return result;
}

/**
 * Problem: Find the maximum depth (height) of a binary tree
 * 
 * @param root Root of the binary tree
 * @returns Maximum depth of the binary tree
 */
function maxDepth(root: TreeNode | null): number {
    if (root === null) return 0;
    
    // Recursively find the depth of left and right subtrees
    const leftDepth = maxDepth(root.left);
    const rightDepth = maxDepth(root.right);
    
    // Return the maximum depth plus 1 (for the current node)
    return Math.max(leftDepth, rightDepth) + 1;
}

// Example usage
// Create a binary tree:
//       1
//      / \
//     2   3
//    / \
//   4   5
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);

console.log(&quot;Preorder traversal:&quot;, preorderTraversal(root));
// Output: Preorder traversal: [1, 2, 4, 5, 3]

console.log(&quot;Inorder traversal:&quot;, inorderTraversal(root));
// Output: Inorder traversal: [4, 2, 5, 1, 3]

console.log(&quot;Postorder traversal:&quot;, postorderTraversal(root));
// Output: Postorder traversal: [4, 5, 2, 3, 1]

console.log(&quot;Maximum depth:&quot;, maxDepth(root));
// Output: Maximum depth: 3
</code></pre>
<h2>LeetCode Example Problems</h2>
<ul>
<li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">LeetCode 144. Binary Tree Preorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">LeetCode 94. Binary Tree Inorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/">LeetCode 145. Binary Tree Postorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">LeetCode 104. Maximum Depth of Binary Tree</a></li>
</ul>
<h2>Complexity Analysis</h2>
<ul>
<li><strong>Time Complexity</strong>: O(n) where n is the number of nodes in the binary tree. We visit each node exactly once.</li>
<li><strong>Space Complexity</strong>: O(h) where h is the height of the binary tree. This is due to the recursion stack. In the worst case (skewed tree), the space complexity could be O(n).</li>
</ul>
<h2>When to Use</h2>
<p>Use Binary Tree DFS when:</p>
<ul>
<li>You need to explore all nodes in a binary tree</li>
<li>You need to process nodes in a specific order (preorder, inorder, postorder)</li>
<li>You're solving problems that require backtracking</li>
<li>You need to find paths in a tree that satisfy certain conditions</li>
<li>You're working with problems that have a natural recursive structure</li>
</ul>

    </div>

    <div class="algorithm-navigation">
        <div class="algorithm-nav-links">
            
                
                
                    
                
                    
                
                    
                
                    
                
                    
                        
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                

                
                

                <div class="algorithm-nav-previous">
                    
                        <a href="/algorithms/04_fast_slow_pointer/" class="algorithm-nav-link">
                            <span class="algorithm-nav-direction">Previous</span>
                            <span class="algorithm-nav-title">Fast and Slow Pointer</span>
                        </a>
                    
                </div>

                <div class="algorithm-nav-index">
                    <a href="/algorithms/" class="algorithm-index-link">All Algorithms</a>
                </div>

                <div class="algorithm-nav-next">
                    
                        <a href="/algorithms/06_binary_tree_bfs/" class="algorithm-nav-link">
                            <span class="algorithm-nav-direction">Next</span>
                            <span class="algorithm-nav-title">Binary Tree BFS (Breadth-First Search)</span>
                        </a>
                    
                </div>
            
        </div>
    </div>
</article>

    </main>
    
    <footer>
        <p>&copy; 2025 Andrii Kuznietsov. All rights reserved.</p>
    </footer>
    <script src="/assets/js/animation.js"></script>
</body>
</html>
