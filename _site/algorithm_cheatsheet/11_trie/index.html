<h1>Trie (Prefix Tree)</h1>
<h2>Description</h2>
<p>A Trie, also called a prefix tree, is a specialized tree-based data structure used for efficient retrieval of keys in a dataset of strings. Each node in the trie represents a single character of a string. The path from the root to a particular node forms a prefix of one or more strings in the dataset. Tries are particularly useful for implementing autocomplete features, spell checkers, and IP routing.</p>
<h2>Use Cases</h2>
<ul>
<li>Autocomplete suggestions</li>
<li>Spell checking</li>
<li>Prefix matching</li>
<li>Word games (like finding all words in a boggle board)</li>
<li>IP routing (longest prefix matching)</li>
<li>T9 predictive text</li>
<li>Implementing dictionaries with prefix operations</li>
</ul>
<h2>Code Example</h2>
<pre><code class="language-typescript">/**
 * Trie node structure
 */
class TrieNode {
    children: Map&lt;string, TrieNode&gt;;
    isEndOfWord: boolean;
    
    constructor() {
        this.children = new Map();
        this.isEndOfWord = false;
    }
}

/**
 * Trie (Prefix Tree) implementation
 */
class Trie {
    private root: TrieNode;
    
    constructor() {
        this.root = new TrieNode();
    }
    
    /**
     * Insert a word into the trie
     * @param word Word to insert
     */
    insert(word: string): void {
        let current = this.root;
        
        for (const char of word) {
            if (!current.children.has(char)) {
                current.children.set(char, new TrieNode());
            }
            current = current.children.get(char)!;
        }
        
        // Mark the end of the word
        current.isEndOfWord = true;
    }
    
    /**
     * Search for a word in the trie
     * @param word Word to search for
     * @returns True if the word exists in the trie, false otherwise
     */
    search(word: string): boolean {
        let current = this.root;
        
        for (const char of word) {
            if (!current.children.has(char)) {
                return false;
            }
            current = current.children.get(char)!;
        }
        
        // Check if this is a complete word
        return current.isEndOfWord;
    }
    
    /**
     * Check if there is any word in the trie that starts with the given prefix
     * @param prefix Prefix to search for
     * @returns True if there is any word with the given prefix, false otherwise
     */
    startsWith(prefix: string): boolean {
        let current = this.root;
        
        for (const char of prefix) {
            if (!current.children.has(char)) {
                return false;
            }
            current = current.children.get(char)!;
        }
        
        return true;
    }
    
    /**
     * Get all words in the trie with the given prefix
     * @param prefix Prefix to search for
     * @returns Array of words with the given prefix
     */
    getWordsWithPrefix(prefix: string): string[] {
        const result: string[] = [];
        let current = this.root;
        
        // Navigate to the node corresponding to the prefix
        for (const char of prefix) {
            if (!current.children.has(char)) {
                return result;
            }
            current = current.children.get(char)!;
        }
        
        // Perform DFS from the prefix node to find all words
        this.dfs(current, prefix, result);
        
        return result;
    }
    
    /**
     * Helper function to perform DFS and collect words
     * @param node Current node
     * @param prefix Current prefix
     * @param result Array to store the words
     */
    private dfs(node: TrieNode, prefix: string, result: string[]): void {
        // If this is the end of a word, add it to the result
        if (node.isEndOfWord) {
            result.push(prefix);
        }
        
        // Explore all children
        for (const [char, childNode] of node.children.entries()) {
            this.dfs(childNode, prefix + char, result);
        }
    }
    
    /**
     * Delete a word from the trie
     * @param word Word to delete
     * @returns True if the word was deleted, false if it doesn't exist
     */
    delete(word: string): boolean {
        return this.deleteHelper(this.root, word, 0);
    }
    
    /**
     * Helper function to recursively delete a word
     * @param node Current node
     * @param word Word to delete
     * @param depth Current depth in the trie
     * @returns True if the node should be deleted, false otherwise
     */
    private deleteHelper(node: TrieNode, word: string, depth: number): boolean {
        // If we've reached the end of the word
        if (depth === word.length) {
            // If the word doesn't exist in the trie
            if (!node.isEndOfWord) {
                return false;
            }
            
            // Mark the end of the word as false
            node.isEndOfWord = false;
            
            // Return true if this node has no children (can be deleted)
            return node.children.size === 0;
        }
        
        const char = word[depth];
        
        // If the character doesn't exist in the trie
        if (!node.children.has(char)) {
            return false;
        }
        
        const childNode = node.children.get(char)!;
        const shouldDeleteChild = this.deleteHelper(childNode, word, depth + 1);
        
        // If the child should be deleted
        if (shouldDeleteChild) {
            node.children.delete(char);
            
            // Return true if this node has no children and is not the end of a word
            return node.children.size === 0 &amp;&amp; !node.isEndOfWord;
        }
        
        return false;
    }
}

// Example usage
const trie = new Trie();

// Insert words
trie.insert(&quot;apple&quot;);
trie.insert(&quot;app&quot;);
trie.insert(&quot;application&quot;);
trie.insert(&quot;banana&quot;);
trie.insert(&quot;ball&quot;);

// Search for words
console.log(&quot;Search 'apple':&quot;, trie.search(&quot;apple&quot;));         // true
console.log(&quot;Search 'app':&quot;, trie.search(&quot;app&quot;));             // true
console.log(&quot;Search 'appl':&quot;, trie.search(&quot;appl&quot;));           // false
console.log(&quot;Search 'orange':&quot;, trie.search(&quot;orange&quot;));       // false

// Check prefixes
console.log(&quot;Starts with 'app':&quot;, trie.startsWith(&quot;app&quot;));    // true
console.log(&quot;Starts with 'ban':&quot;, trie.startsWith(&quot;ban&quot;));    // true
console.log(&quot;Starts with 'ora':&quot;, trie.startsWith(&quot;ora&quot;));    // false

// Get words with prefix
console.log(&quot;Words with prefix 'app':&quot;, trie.getWordsWithPrefix(&quot;app&quot;));
// Output: Words with prefix 'app': [&quot;app&quot;, &quot;apple&quot;, &quot;application&quot;]

// Delete a word
console.log(&quot;Delete 'apple':&quot;, trie.delete(&quot;apple&quot;));         // true
console.log(&quot;Search 'apple' after deletion:&quot;, trie.search(&quot;apple&quot;)); // false
console.log(&quot;Search 'app' after deletion:&quot;, trie.search(&quot;app&quot;));     // true
</code></pre>
<h2>LeetCode Example Problems</h2>
<ul>
<li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/">LeetCode 208. Implement Trie (Prefix Tree)</a></li>
<li><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">LeetCode 211. Design Add and Search Words Data Structure</a></li>
<li><a href="https://leetcode.com/problems/word-search-ii/">LeetCode 212. Word Search II</a></li>
<li><a href="https://leetcode.com/problems/replace-words/">LeetCode 648. Replace Words</a></li>
<li><a href="https://leetcode.com/problems/map-sum-pairs/">LeetCode 677. Map Sum Pairs</a></li>
</ul>
<h2>Complexity Analysis</h2>
<ul>
<li>
<p><strong>Time Complexity</strong>:</p>
<ul>
<li>Insertion: O(m) where m is the length of the word being inserted.</li>
<li>Search: O(m) where m is the length of the word being searched.</li>
<li>Prefix Search: O(m) where m is the length of the prefix.</li>
<li>Get Words with Prefix: O(n) where n is the total number of characters in all words with the given prefix.</li>
<li>Deletion: O(m) where m is the length of the word being deleted.</li>
</ul>
</li>
<li>
<p><strong>Space Complexity</strong>: O(n * m) where n is the number of words and m is the average length of the words. In the worst case, if there are no common prefixes, the space complexity would be the sum of the lengths of all words.</p>
</li>
</ul>
<h2>When to Use</h2>
<p>Use a Trie when:</p>
<ul>
<li>You need to efficiently store and retrieve strings</li>
<li>You need to perform prefix-based operations (like autocomplete)</li>
<li>You're working with a large dictionary of words</li>
<li>You need to check if a string is a prefix of any string in a dataset</li>
<li>You're implementing a spell checker or a word game</li>
<li>You need to find all words with a common prefix</li>
</ul>
